# Дополнительное задание — калькулятор

Содержание:
* [Задание (ТЗ)](#задание-тз)
* [Реализация](#реализация)
  * [Запуск программы](#запуск-программы)
  * [Подробнее о реализации](#подробнее-о-реализации)

## Задание (ТЗ)

>Необходимо написать калькулятор, принимающий строку с выражением (+,-,*,/), предусмотреть возможность использование скобок. Вывести в консоль результат выражения. Необходимо использовать java 8.

Дополнения по уточненному ТЗ: 
* Числа принимаются целые и вещественные.
* Проверки введенных данных по 2-3 случаям на собственный выбор.

## Реализация

Запускается программа (подробнее в разделе ["Запуск программы"](#запуск-программы)). После запуска на вход ожидается одна строка. 
Проверяется корректность строки по следующим пунктам:
* Количество скобок.
* Наличие "лишних" символов: буквы и прочие символы, которые не образуют операторы или операнды.

Ответ выводится в консоль, и на этом работа программы заканчивается. Есть следующие варианты:
* Посчитанное значение.
* Некорректный ввод.
* Ошибка при вычислениях (деление на ноль и пр.).

Если нужно еще что-то посчитать, надо заново запустить программу.

### Запуск программы

Переходим в папку src. Собираем и запускаем калькулятор:
* `javac Calc.java`
* `java Calc`

Вместе с калькулятором идут тесты, они лежат в той же папке src. Собираем и запускаем тесты аналогичным образом:
* `javac CalcTest.java`
* `java CalcTest`

В отличие от самого калькулятора, тесты не требуют никакого ввода — все тестируемые значения уже заложены в программу, можно дополнить код тестов при необходимости.

Если нужны и тесты, и сам калькулятор, то лучше скомпилировать файл с тестами: появятся сразу нужные файлы Calc и CalcTest.

### Подробнее о реализации

Калькулятор реализован на основе обратной польской записи, этот метод широко используется в информатике. 

Суть в том, что в один стек мы кладем числа (операнды), а в другой — операторы. 
Обрабатываем операции в соответствии с приоритетами, принятыми в математике, вытаскивая из стеков операторы и операнды по необходимости и производя вычисления с более приоритетными, чем плюс или минус, операциями. Отдельно обрабатываем случаи с унарным минусом: если он стоит в самом начале выражения или перед скобкой — иначе такой минус является бинарным.

Выбор такой реализации обоснован тем, что это была первая идея, которая пришла в голову, и лучше придумать уже не получилось. 
Использование минимального количества технологий (например, отсутствие библиотеки JUnit в тестах) объясню тем, что подобное задание, как мне показалось, не требует сверхнавороченности, особенно если по ТЗ командный интерфейс — в общем, я выбрала минимализм :).

Я с польской нотацией познакомилась на отборочном интенсиве Школы 21, основную идею польской нотации не забыла, так что во второй раз реализовать алгоритм подсчета выражений было не так сложно, хоть и возникали некоторые трудности, в частности с унарным минусом.